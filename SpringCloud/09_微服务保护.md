# Sentinel

## 1. 雪崩问题及解决方案

**雪崩问题**：微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。

解决雪崩问题的常见方式有四种：

**(1) 超时处理**：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待。

![image-20210715172820438](img/image-20210715172820438.png)

**(2) 仓壁模式**：限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。

![image-20210715173215243](img/image-20210715173215243.png)

**(3) 断路器模式**：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。

![image-20210715173428073](img/image-20210715173428073.png)

上图中当发现访问服务D的请求异常比例过高时，认为服务D有导致雪崩的风险，会拦截访问服务D的一切请求，形成熔断。

**(4) 流量控制**：限制业务访问的QPS，避免服务因流量的突增而故障。

![image-20210715173555158](img/image-20210715173555158.png)



## 2. 服务保护技术对比

在SpringCloud当中支持多种服务保护技术：

- [Netfix Hystrix](https://github.com/Netflix/Hystrix)
- [Sentinel](https://github.com/alibaba/Sentinel)
- [Resilience4J](https://github.com/resilience4j/resilience4j)

早期比较流行的是Hystrix框架，但目前国内使用最广泛的还是阿里巴巴的Sentinel框架，这里我们做下对比：

|                | **Sentinel**                                   | **Hystrix**                   |
| -------------- | ---------------------------------------------- | ----------------------------- |
| 隔离策略       | 信号量隔离                                     | 线程池隔离/信号量隔离         |
| 熔断降级策略   | 基于慢调用比例或异常比例                       | 基于失败比率                  |
| 实时指标实现   | 滑动窗口                                       | 滑动窗口（基于 RxJava）       |
| 规则配置       | 支持多种数据源                                 | 支持多种数据源                |
| 扩展性         | 多个扩展点                                     | 插件的形式                    |
| 基于注解的支持 | 支持                                           | 支持                          |
| 限流           | 基于 QPS，支持基于调用关系的限流               | 有限的支持                    |
| 流量整形       | 支持慢启动、匀速排队模式                       | 不支持                        |
| 系统自适应保护 | 支持                                           | 不支持                        |
| 控制台         | 开箱即用，可配置规则、查看秒级监控、机器发现等 | 不完善                        |
| 常见框架的适配 | Servlet、Spring Cloud、Dubbo、gRPC  等         | Servlet、Spring Cloud Netflix |



## 3. Sentinel介绍和安装

Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：https://sentinelguard.io/zh-cn/index.html

Sentinel 具有以下特征:

**丰富的应用场景**：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。

**完备的实时监控**：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。

**广泛的开源生态**：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。

**完善的** **SPI** **扩展点**：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。



**安装Sentinel**

1）下载

sentinel官方提供了UI控制台，方便我们对系统做限流设置。可以在[GitHub](https://github.com/alibaba/Sentinel/releases)下载。

资料也提供了下载好的jar包：

![2023-08-09_232612](img/2023-08-09_232612.png)

2）运行

将jar包放到任意非中文目录，执行命令：

```sh
java -jar sentinel-dashboard-1.8.6.jar
```

如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：

| **配置项**                       | **默认值** | **说明**   |
| -------------------------------- | ---------- | ---------- |
| server.port                      | 8080       | 服务端口   |
| sentinel.dashboard.auth.username | sentinel   | 默认用户名 |
| sentinel.dashboard.auth.password | sentinel   | 默认密码   |

例如，修改端口：

```sh
java -Dserver.port=8090 -jar sentinel-dashboard-1.8.6.jar
```

3）访问

访问http://localhost:8090页面，就可以看到sentinel的控制台了，用户名密码默认都为sentinel：

![image-20210715190827846](img/image-20210715190827846.png)



## 4. 微服务整合Sentinel

我们在order-service中整合sentinel，并连接sentinel的控制台，步骤如下：

1）引入sentinel依赖

```xml
<!--sentinel-->
<dependency>
    <groupId>com.alibaba.cloud</groupId> 
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

2）配置控制台

修改application.yaml文件，添加下面内容：

```yaml
server:
  port: 8080
spring:
  cloud: 
    sentinel:
      transport:
        dashboard: localhost:8090
```

3）访问order-service的任意端点

打开浏览器，访问http://localhost:8080/order/101，这样才能触发sentinel的监控。

然后再访问sentinel的控制台，查看效果：

![2023-08-09_232326](img/2023-08-09_232326.png)



## 5. 流量控制

### 5.1 簇点链路

当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做**簇点链路**。簇点链路中被监控的每一个接口就是一个**资源**。

默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。

例如，我们刚才访问的order-service中的OrderController中的端点：/order/{orderId}

![2023-08-09_105733](img/2023-08-09_105733.png)

流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：

- 流控：流量控制
- 降级：降级熔断
- 热点：热点参数限流，是限流的一种
- 授权：请求的权限控制

点击资源/order/{orderId}后面的流控按钮，就可以弹出表单。

![2023-08-09_110112](img/2023-08-09_110112.png)

**QPS的是指每秒请求数**，上述设置含义是限制 /order/{orderId}这个资源每秒只允许1次请求，超出的请求会被拦截并报错。



### 5.2 jmeter快速入门

(1) 安装jmeter

Jmeter依赖于JDK，所以必须确保当前计算机上已经安装了JDK，并且配置了环境变量。

可以Apache Jmeter官网下载，地址：http://jmeter.apache.org/download_jmeter.cgi

![2023-08-09_120435](img/2023-08-09_120435.png)

资料也提供了下载好的安装包，因为下载的是zip包，解压缩即可使用，其中的bin目录就是执行的脚本，其中包含启动脚本：

![2023-08-09_133437](img/2023-08-09_133437.png)

双击即可运行，但是有两点注意：

- 启动速度比较慢，要耐心等待
- 启动后黑窗口不能关闭，否则Jmeter也跟着关闭了

(2) 基本用法

在测试计划上点鼠标右键，选择添加 > 线程（用户） > 线程组：

![2023-08-09_133825](img/2023-08-09_133825.png)

在新增的线程组中，填写线程信息：

![2023-08-09_134124](img/2023-08-09_134124.png)

给线程组点鼠标右键，添加http取样器：

![2023-08-09_134528](img/2023-08-09_134528.png)

编写取样器内容：

![2023-08-09_134755](img/2023-08-09_134755.png)



案例：给 /order/{orderId}这个资源设置流控规则，QPS不能超过 5，然后测试。

1）首先在sentinel控制台添加限流规则

![image-20210715192455429](img/image-20210715192455429.png)

2）利用jmeter测试

资料提供了编写好的Jmeter测试样例：

![2023-08-09_114226](img/2023-08-09_114226.png)

打开jmeter，导入资料提供的测试样例（注意端口号是否对应），选中`流控入门，QPS<5`右键运行：

![2023-08-09_135239](img/2023-08-09_135239.png)

查看结果：

![2023-08-09_140046](img/2023-08-09_140046.png)



### 5.3 流控模式

在添加限流规则时，点击高级选项，可以选择三种**流控模式**：

- 直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式
- 关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流
- 链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流

![image-20210715201827886](img/image-20210715201827886.png)

#### 关联模式

统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流。

配置规则：

![image-20210715202540786](img/image-20210715202540786.png)

语法说明：当/write资源访问量触发阈值时，就会对/read资源限流，避免影响/write资源。

使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。

需求说明：

- 在OrderController新建两个端点：/order/query和/order/update，无需实现业务

- 配置流控规则，当/order/ update资源被访问的QPS超过5时，对/order/query请求限流

1）定义/order/query端点，模拟订单查询

```java
@GetMapping("/query")
public String queryOrder() {
    return "查询订单成功";
}
```

2）定义/order/update端点，模拟订单更新

```java
@GetMapping("/update")
public String updateOrder() {
    return "更新订单成功";
}
```

重启服务，查看sentinel控制台的簇点链路：

![2023-08-09_142420](img/2023-08-09_142420.png)

3）配置流控规则

对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询/order/query限流，因此点击它后面的流控按钮：

![2023-08-09_142943](img/2023-08-09_142943.png)

4）在Jmeter测试

选择《流控模式-关联》启动：

![2023-08-09_143246](img/2023-08-09_143246.png)

请求的目标是/order/update，因为QPS大于阈值这样这个断点就会触发阈值，但限流的目标是/order/query。

在浏览器访问：[localhost:8080/order/query](http://localhost:8080/order/query)

![2023-08-09_143538](img/2023-08-09_143538.png)



#### 链路模式

只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。

配置示例：例如有两条请求链路：

- /test1 --> /common

- /test2 --> /common

如果只希望统计从/test2进入到/common的请求，则可以这样配置：

![image-20210716103536346](img/image-20210716103536346.png)

**实战案例**

需求：有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。

步骤：

(1) 在OrderServiceImpl中添加一个queryGoods方法，不用实现业务

```Java
public void queryGoods(){
    System.err.println("查询商品");
}
```

(2) 在OrderController中，改造/order/query端点，调用OrderServiceImpl中的queryGoods方法

```Java
@GetMapping("/query")
public String queryOrder() {
    // 查询商品
    orderService.queryGoods();
    // 查询订单
    System.out.println("查询订单");
    return "查询订单成功";
}
```

(3) 在OrderController中添加一个/order/save的端点，调用OrderServiceImpl的queryGoods方法

```java
@GetMapping("/save")
public String saveOrder() {
    // 查询商品
    orderService.queryGoods();
    // 查询订单
    System.err.println("新增订单");
    return "新增订单成功";
}
```

(4) 给queryGoods设置限流规则，从/order/query进入queryGoods的方法限制QPS必须小于2

默认情况下，OrderServiceImpl中的方法是不被Sentinel监控的，需要我们自己通过注解来标记要监控的方法。

给OrderServiceImpl的queryGoods方法添加 `@SentinelResource` 注解，注解内指定资源名称。

```java
@SentinelResource("goods")
public void queryGoods(){
    System.err.println("查询商品");
}
```

链路模式中，是对不同来源的两个链路做监控。但是sentinel默认会给进入SpringMVC的所有请求设置同一个root资源，会导致链路模式失效。我们需要关闭这种对SpringMVC的资源聚合，修改order-service服务的application.yml文件：

```yml
spring:
  cloud:
    sentinel:
      web-context-unify: false # 关闭context整合
```

重启服务，访问/order/query和/order/save，可以查看到sentinel的簇点链路规则中，出现了新的资源：

![2023-08-09_150710](img/2023-08-09_150710.png)

(5) 添加流控规则

只统计从/order/query进入/goods的资源，QPS阈值为2，超出则被限流。

点击goods资源后面的流控按钮，在弹出的表单中填写下面信息：

<img src="img/image-20210716105408723.png" alt="image-20210716105408723" style="zoom:67%;" />

(6) Jmeter测试

选择《流控模式-链路》启动：

<img src="img/2023-08-09_145147.png" alt="2023-08-09_145147" style="zoom: 80%;" />

查看结果：

<img src="img/2023-08-09_151005.png" alt="2023-08-09_151005" style="zoom: 80%;" />



### 5.4 流控效果

在流控的高级选项中，还有一个流控效果选项：

![image-20210716110225104](img/image-20210716110225104.png)

流控效果是指请求达到流控阈值时应该采取的措施，包括三种：

- 快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。

- warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。

- 排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长



#### warm up

阈值一般是一个微服务能承担的最大QPS，但是一个服务刚刚启动时，一切资源尚未初始化（**冷启动**），如果直接将QPS跑到最大值，可能导致服务瞬间宕机。

warm up也叫**预热模式**，是应对服务冷启动的一种方案。请求阈值初始值是 maxThreshold / coldFactor，持续指定时长后，逐渐提高到maxThreshold值。而coldFactor的默认值是3.

例如，我设置QPS的maxThreshold为10，预热时间为5秒，那么初始阈值就是 10 / 3 ，也就是3，然后在5秒后逐渐增长到10.

<img src="img/image-20210716110629796.png" alt="image-20210716110629796" style="zoom:80%;" />

案例：给/order/{orderId}这个资源设置限流，最大QPS为10，利用warm up效果，预热时长为5秒

<img src="img/image-20210716111012387.png" alt="image-20210716111012387" style="zoom:67%;" />



#### 排队等待

当请求超过QPS阈值时，快速失败和warm up 会拒绝新的请求并抛出异常。

而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。

例如：QPS = 5，即200ms处理一个队列中的请求；timeout = 2000，意味着预期等待时长超过2000ms的请求会被拒绝并抛出异常。

比如现在一下子来了12 个请求，因为每200ms执行一个请求，那么：

- 第6个请求的预期等待时长 =  200 * （6 - 1） = 1000ms
- 第12个请求的预期等待时长 = 200 * （12-1） = 2200ms，被抛弃

第1秒同时接收到10个请求，但第2秒只有1个请求。如果使用队列模式做流控，以固定的200ms的间隔执行，QPS会变的很平滑：

![图片1](img/图片1.png)



案例：给/order/{orderId}这个资源设置限流，最大QPS为10，利用排队的流控效果，超时时长设置为5s

<img src="img/image-20210716114048918.png" alt="image-20210716114048918" style="zoom:80%;" />



### 5.5 热点参数限流

之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是分别统计参数值相同的请求，判断是否超过QPS阈值。

例如，一个根据id查询商品的接口：

![image-20210716115014663](img/image-20210716115014663.png)

访问/goods/{id}的请求中，id参数值会有变化，热点参数限流会根据参数值分别统计QPS，统计结果：

<img src="img/image-20210716115131463.png" alt="image-20210716115131463" style="zoom:80%;" />

当id=1的请求触发阈值被限流时，id值不为1的请求不受影响。

配置示例：对hot这个资源的0号索引参数（第一个参数）做统计，每1秒相同参数值的请求数不能超过5。

![image-20210716115232426](img/image-20210716115232426.png)

上述配置，对查询商品这个接口的所有商品QPS都限定为5，而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样，高一些。那就需要配置热点参数限流的高级选项了：

![image-20210716115717523](img/image-20210716115717523.png)

这里的含义是对0号的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外：

- 如果参数值是100，则每1秒允许的QPS为10


- 如果参数值是101，则每1秒允许的QPS为15



**案例需求**：给/order/{orderId}这个资源添加热点参数限流，规则如下：

- 默认的热点参数规则是每1秒请求量不超过2

- 给102这个参数设置例外：每1秒请求量不超过4

- 给103这个参数设置例外：每1秒请求量不超过10

**注意**：热点参数限流对默认的SpringMVC资源无效，需要利用@SentinelResource注解标记资源

(1) 标记资源

给order-service中的OrderController中的/order/{orderId}资源添加注解：

![2023-08-09_163915](img/2023-08-09_163915.png)

(2) 热点参数限流规则

点击左侧菜单中热点规则菜单：

<img src="img/image-20210716120319009.png" alt="image-20210716120319009" style="zoom: 50%;" />

填写限流规则：

<img src="img/image-20210716120536714.png" alt="image-20210716120536714" style="zoom:67%;" />

(3) Jmeter测试

选择《热点参数限流 QPS1》启动

<img src="img/2023-08-09_165536.png" alt="2023-08-09_165536" style="zoom: 80%;" />

查看结果：

![2023-08-09_165206](img/2023-08-09_165206.png)



## 6. 隔离和降级

限流是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。

而要将这些故障控制在一定范围，避免雪崩，就要靠**线程隔离**（舱壁模式）和**熔断降级**手段了。

**线程隔离**之前讲到过：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。

**熔断降级**：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。

不管是线程隔离还是熔断降级，都是对**客户端**（调用方）的保护。需要在**调用方** 发起远程调用时做线程隔离、或者服务熔断。

微服务远程调用都是基于Feign来完成的，因此需要将Feign与Sentinel整合，在Feign里面实现线程隔离和服务熔断。

### 6.1 FeignClient整合Sentinel

SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。

(1) 修改配置，开启sentinel功能

修改OrderService的application.yml文件，开启Feign的Sentinel功能：

```yml
feign:
  sentinel:
    enabled: true # 开启feign对sentinel的支持
```

(2) 编写失败降级逻辑

业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。

①方式一：FallbackClass，无法对远程调用的异常做处理

②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种

这里演示方式二的失败降级处理：

(1) 在feing-api项目中定义类，实现FallbackFactory：

```Java
@Slf4j
public class UserClientFallbackFactory implements FallbackFactory<UserClient> {
    @Override
    public UserClient create(Throwable throwable) {
        return new UserClient() {
            @Override
            public User findById(Long id) {
                // 编写降级逻辑
                log.error("查询用户异常", throwable);
                return new User();
            }
        };
    }
}
```

![2023-08-09_171031](img/2023-08-09_171031.png)

(2) 在feing-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean：

```java
@Bean
public UserClientFallbackFactory userClientFallbackFactory(){
    return new UserClientFallbackFactory();
}
```

(3) 在feing-api项目中的UserClient接口中使用UserClientFallbackFactory：

```java
@FeignClient(value = "userservice", fallbackFactory = UserClientFallbackFactory.class)
public interface UserClient {

    @GetMapping("/user/{id}")
    User findById(@PathVariable("id") Long id);
}
```

重启后，访问一次订单查询业务，然后查看sentinel控制台，可以看到新的簇点链路：

<img src="img/image-20210716123705780.png" alt="image-20210716123705780" style="zoom:67%;" />



### 6.2 sentinel的线程隔离

线程隔离有两种方式实现：

- 线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果
- 信号量隔离：Sentinel默认采用。不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。

<img src="img/image-20210716123036937.png" alt="image-20210716123036937" style="zoom:67%;" />

**用法说明**：

在添加限流规则时，可以选择两种阈值类型：

<img src="img/2023-08-09_233239.png" alt="2023-08-09_233239" style="zoom:80%;" />

- QPS：就是每秒的请求数，在快速入门中已经演示过

- 线程数：是该资源能使用用的tomcat线程数的最大值。也就是通过限制线程数量，实现**线程隔离**（舱壁模式）。



**案例需求**：给 order-service服务中的UserClient的查询用户接口设置流控规则，线程数不能超过 2。

(1) 配置隔离规则

选择feign接口后面的流控按钮

![image-20210716123831992](img/image-20210716123831992.png)

填写表单：

<img src="img/2023-08-09_233048.png" alt="2023-08-09_233048" style="zoom:80%;" />

(2) Jmeter测试

选择《阈值类型-线程数<2》：

![image-20210716124229894](img/image-20210716124229894.png)

一次发生10个请求，有较大概率并发线程数超过2，而超出的请求会走之前定义的失败降级逻辑。

查看运行结果：

![image-20210716124147820](img/image-20210716124147820.png)

虽然结果都是通过了，不过部分请求得到的响应是降级返回的null信息。



### 6.3 熔断降级

熔断降级是解决雪崩问题的重要手段。其思路是由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会**熔断**该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。

断路器控制熔断和放行是通过状态机来完成的：

![image-20210716130958518](img/image-20210716130958518.png)

状态机包括三个状态：

- closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态
- open：打开状态，服务调用被**熔断**，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态
- half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。
  - 请求成功：则切换到closed状态
  - 请求失败：则切换到open状态

断路器熔断策略有三种：慢调用、异常比例、异常数。

#### 慢调用

业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。

例如下图所示规则：RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次，并且慢调用比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次请求做测试。

![image-20210716145934347](img/image-20210716145934347.png)

**案例需求**：给 UserClient的查询用户接口设置降级规则，慢调用的RT阈值为50ms，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5。

(1) 设置慢调用

修改user-service中的/user/{id}这个接口的业务。通过休眠模拟一个延迟时间：

<img src="img/image-20210716150234787.png" alt="image-20210716150234787" style="zoom: 80%;" />

此时，orderId=101的订单，关联的是id为1的用户，调用时长为82ms，orderId=102的订单，关联的是id为2的用户，调用时长为16ms

![2023-08-09_184317](img/2023-08-09_184317.png)

(2) 设置熔断规则

给feign接口设置降级规则：超过50ms的请求都认为是慢请求。

![2023-08-10_001141](img/2023-08-10_001141.png)

![image-20210716150740434](img/image-20210716150740434.png)

(3) 测试

在浏览器访问：http://localhost:8080/order/101，快速刷新5次，可以发现触发了熔断，请求时长缩短至9ms，快速失败了，并且走降级逻辑，返回的null。

<img src="img/2023-08-10_000414.png" alt="2023-08-10_000414" style="zoom:80%;" />

在浏览器访问：http://localhost:8080/order/102，被熔断了，走的降级逻辑。

<img src="img/2023-08-10_000556.png" alt="2023-08-10_000556" style="zoom:80%;" />



#### 异常比例、异常数

统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。

例如，一个异常比例设置：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.4，则触发熔断。如下所示。

![image-20210716131430682](img/image-20210716131430682.png)



**案例需求**：给 UserClient的查询用户接口设置降级规则，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5

(1) 设置异常请求

修改user-service中的/user/{id}这个接口的业务，id 为 2时，手动抛出异常，以触发异常比例的熔断：

![image-20210716151348183](img/image-20210716151348183.png)

(2) 设置熔断规则

给feign接口设置降级规则：在5次请求中，只要异常比例超过0.4，也就是有2次以上的异常，就会触发熔断。

<img src="img/2023-08-10_104044.png" alt="2023-08-10_104044" style="zoom:80%;" />

(3) 测试

在浏览器快速访问：http://localhost:8080/order/102，快速刷新5次，触发熔断：

<img src="img/2023-08-10_001623.png" alt="2023-08-10_001623" style="zoom:80%;" />

同时去访问本来应该正常的103，也执行了降级逻辑。

<img src="img/2023-08-10_001718.png" alt="2023-08-10_001718" style="zoom:80%;" />



## 7. 授权规则

授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。

- 白名单：来源（origin）在白名单内的调用者允许访问
- 黑名单：来源（origin）在黑名单内的调用者不允许访问

点击左侧菜单的授权规则，新增授权规则：

<img src="img/2023-08-10_114740.png" alt="2023-08-10_114740" style="zoom:80%;" />

资源名：就是受保护的资源，例如/order/{orderId}

流控应用：是来源者的名单（请求头信息）

如果是勾选白名单，则名单中的来源被许可访问；如果是勾选黑名单，则名单中的来源被禁止访问。

比如允许请求从gateway到order-service，不允许浏览器访问，那么白名单中就要填写网关的来源名称（请求头：origin）

<img src="img/image-20210716152349191.png" alt="image-20210716152349191" style="zoom:67%;" />

### 7.1 获取origin

Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。

```java
public interface RequestOriginParser {
    /**
     * 从请求request对象中获取origin，获取方式自定义
     */
    String parseOrigin(HttpServletRequest request);
}
```

这个方法的作用就是从request对象中，获取请求者的origin值并返回。

默认情况下，sentinel不管请求者从哪里来，返回值永远是default，也就是说一切请求的来源都被认为是一样的值default。

因此，需要自定义这个接口的实现，让**不同的请求，返回不同的origin**。这样会尝试从request-header中获取origin值。

例如order-service服务中，在com.springcloud.sentinel包下定义一个RequestOriginParser的实现类：

```java
@Component
public class HeaderOriginParser implements RequestOriginParser {
    @Override
    public String parseOrigin(HttpServletRequest request) {
        // 1.获取请求头
        String origin = request.getHeader("origin");
        // 2.非空判断
        if (StringUtils.isEmpty(origin)) {
            origin = "blank";
        }
        return origin;
    }
}
```



### 7.2 给网关添加请求头

既然获取请求origin的方式是从request-header中获取origin值，我们必须让**所有从gateway路由到微服务的请求都带上origin头**。

这个需要利用之前学习的一个GatewayFilter来实现，AddRequestHeaderGatewayFilter。

修改gateway服务中的application.yml，添加一个defaultFilter：

```yaml
spring:
  cloud:
    gateway:
      default-filters:
        - AddRequestHeader=origin,gateway
      routes:
        - id: order-service
          uri: lb://orderservice
          predicates:
            - Path=/order/**
```

这样，从gateway路由的所有请求都会带上origin头，值为gateway，而从其它地方到达微服务的请求则没有这个头。



### 7.3 配置授权规则

添加一个授权规则，放行origin值为gateway的请求：

<img src="img/2023-08-10_121802.png" alt="2023-08-10_121802" style="zoom:80%;" />

规则如下：

<img src="img/2023-08-10_121922.png" alt="2023-08-10_121922" style="zoom:80%;" />

现在，我们直接跳过网关，访问order-service服务：

![2023-08-10_122241](img/2023-08-10_122241.png)

通过网关访问，不受影响：

![2023-08-10_143538](img/2023-08-10_143538.png)



### 7.4 自定义异常结果

默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。

如果要自定义异常时的返回结果，需要实现 `BlockExceptionHandler` 接口：

```java
public interface BlockExceptionHandler {
    /**
     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException
     */
    void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception;
}
```

这个方法有三个参数：

- HttpServletRequest request：request对象
- HttpServletResponse response：response对象
- BlockException e：被sentinel拦截时抛出的异常

这里的BlockException包含多个不同的子类：

| **异常**             | **说明**           |
| -------------------- | ------------------ |
| FlowException        | 限流异常           |
| ParamFlowException   | 热点参数限流的异常 |
| DegradeException     | 降级异常           |
| AuthorityException   | 授权规则异常       |
| SystemBlockException | 系统规则异常       |

下面在order-service定义一个自定义异常处理类实现 `BlockExceptionHandler` 接口：

```Java
@Component
public class SentinelExceptionHandler implements BlockExceptionHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception {
        String msg = "未知异常";
        int status = 429;

        if (e instanceof FlowException) {
            msg = "请求被限流了";
        } else if (e instanceof ParamFlowException) {
            msg = "请求被热点参数限流";
        } else if (e instanceof DegradeException) {
            msg = "请求被降级了";
        } else if (e instanceof AuthorityException) {
            msg = "没有权限访问";
            status = 401;
        }

        response.setContentType("application/json;charset=utf-8");
        response.setStatus(status);
        response.getWriter().println("{\"msg\": " + msg + ", \"status\": " + status + "}");
    }
}
```

重启测试，在不同场景下，会返回不同的异常消息：

限流异常：

![2023-08-10_145041](img/2023-08-10_145041.png)

授权规则异常：

![2023-08-10_145127](img/2023-08-10_145127.png)



### 7.5 规则持久化

sentinel的所有规则都是内存存储，重启后所有规则都会丢失。在生产环境下，我们必须确保这些规则的持久化，避免丢失。

规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式：

- 原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。
- pull模式
- push模式



#### pull模式

pull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。

<img src="img/image-20210716154155238.png" alt="image-20210716154155238" style="zoom:80%;" />



#### push模式

push模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。

<img src="img/image-20210716154215456.png" alt="image-20210716154215456" style="zoom:80%;" />

实现push模式参考资料提供的《sentinel规则持久化》，修改后的项目也在资料中提供了。

![2023-08-10_145908](img/2023-08-10_145908.png)


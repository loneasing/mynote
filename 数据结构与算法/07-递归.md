## 递归


递归是一种在解决问题时使用自身定义的方法或函数的过程。在递归过程中，函数会重复调用自身来解决较小规模的问题，直到达到基本情况（递归终止条件），然后逐层返回结果，最终得到整个问题的解。

递归可以看作是一种将复杂问题分解为更小、相似且可解决的子问题的方法。递归的关键在于问题的规模逐步缩小，使得每个子问题都可以用相同的方法来解决。这种递归的思想使得代码更加简洁、易于理解，并且可以处理一些具有自相似性质的问题。

在使用递归时，需要明确定义递归函数的基本情况，即递归终止条件，以避免无限递归。**递归函数的调用过程形成一个递归栈，每次函数调用都会在栈上创建一个新的帧，保存局部变量和返回地址**。当达到递归终止条件时，递归栈会逐层弹出帧，返回结果，最终完成整个递归过程。

**递归要遵守以下两个重要原则**：

1. 递归终止条件：递归函数必须定义一个或多个终止条件，用于指定递归何时结束。在递归过程中，当满足终止条件时，递归将停止并返回结果，防止无限递归。
2. 递归调用：递归函数必须包含对自身的调用，以解决规模更小的子问题。在每次递归调用时，问题的规模应该比原始问题更小。通过不断地将问题分解为更小的子问题，逐步逼近终止条件，最终解决原始问题。

遵守这两个原则能确保递归的正确性和终止性。在编写递归函数时，需要仔细考虑终止条件和递归调用的方式，以避免出现无限递归或无法终止的情况。

**递归和回溯是相关但不完全相同的概念**

递归是一种编程技术，通过将一个问题分解为更小的子问题来解决。递归函数会在每次调用时，将问题的规模缩小，直到达到终止条件。递归可以用于解决各种问题，包括但不限于回溯问题。

回溯是一种特定的搜索算法，用于在问题的解空间中寻找满足特定条件的解。回溯算法通过尝试不同的选择，逐步构建解，并在遇到无效选择时进行回退（回溯），继续尝试其他可能的选择。回溯算法通常通过递归的方式实现，每个递归层级代表一次选择。

可以说，回溯算法是一种使用递归的技术，用于解决需要穷举所有可能解的问题。递归提供了回溯算法所需的迭代和尝试不同选择的能力。在回溯过程中，递归函数会根据问题的特定条件进行选择和回退，以找到满足条件的解或穷尽所有可能。

因此，递归是一种更广泛的概念，而回溯是一种特定的应用场景下使用递归的方法。递归可以用于解决各种问题，而回溯则是递归的一种特殊用法，用于解决需要回退和尝试不同选择的搜索问题。

递归常见的应用包括树的遍历、排序算法（如快速排序和归并排序）、图的深度优先搜索等。使用递归时需要注意递归深度和性能问题，有时候可以使用迭代等其他方法来替代递归。

▼下面是一个经典的递归示例，计算阶乘的函数：

```Java
public class RecursiveFactorial {
    public static int factorial(int n) {
        // 递归终止条件
        if (n == 0 || n == 1) {
            return 1;
        }

        // 递归调用
        return n * factorial(n - 1);
    }
}
```



### 迷宫问题

解决迷宫问题的思路如下：

1. 定义迷宫：将迷宫表示为一个二维数组，其中0表示可通行的空格，1表示墙或障碍物，以及一个起点和一个终点。
2. 定义递归函数：定义一个递归函数，用于在迷宫中寻找路径。该函数的输入参数包括当前位置的行和列，以及之前访问过的路径。
3. 设定递归终止条件：当当前位置为终点时，表示已经找到一条路径，将其添加到结果集中。在递归终止条件下，返回或继续探索其他可能的路径。
4. 判断当前位置的可行方向：根据当前位置的四个邻接位置（上、下、左、右），判断是否可行。如果邻接位置是可通行的空格且未访问过，则将其作为下一步的候选位置。
5. 递归调用：对于每个可行的候选位置，将其标记为已访问，并递归调用函数继续探索下一步。
6. 回溯操作：如果当前位置的所有邻接位置都不可行，或者已经找到所有路径，需要进行回溯操作。回溯操作包括将当前位置标记为未访问，返回上一步，并继续尝试其他可行的方向。
7. 遍历所有路径：通过递归调用，不断在迷宫中寻找可行路径，直到找到所有路径或遍历完所有可能的位置。
8. 输出结果：将找到的所有路径进行输出，可以打印出路径的行走轨迹或其他形式的展示。

▼下面是一个简单的Java代码示例，用于解决迷宫问题：

```Java
public class MazeSolver {
    private static final int PATH = 0;
    private static final int WALL = 1;
    private static final int VISITED = 2;

    // 用二维数组定义一个迷宫
    private static int[][] maze = {
            {0, 1, 1, 1, 1},
            {0, 0, 0, 1, 1},
            {1, 1, 0, 0, 1},
            {1, 1, 1, 0, 0},
            {1, 1, 1, 1, 0}
    };

    public static boolean solveMaze(int row, int col) {
        // 判断当前位置是否越界或为墙壁
        if (row < 0 || col < 0 || row >= maze.length || col >= maze[0].length || maze[row][col] != PATH) {
            return false;
        }

        // 到达终点
        if (row == maze.length - 1 && col == maze[0].length - 1) {
            return true;
        }

        // 标记当前位置为已访问
        maze[row][col] = VISITED;

        // 递归探索四个方向(找路策略，修改策略会影响路径)
        if (solveMaze(row - 1, col)) { // 上
            return true;
        }
        if (solveMaze(row + 1, col)) { // 下
            return true;
        }
        if (solveMaze(row, col - 1)) { // 左
            return true;
        }
        if (solveMaze(row, col + 1)) { // 右
            return true;
        }

        // 如果四个方向都无法到达终点，则将当前位置重新标记为可通行路径
        maze[row][col] = PATH;
        return false;
    }

    public static void main(String[] args) {
        if (solveMaze(0, 0)) {
            System.out.println("迷宫有解！");
        } else {
            System.out.println("迷宫无解！");
        }
    }
}
```

在上述代码中，我们定义了一个 `maze` 二维数组来表示迷宫，0 表示可通行路径，1 表示墙壁。`solveMaze` 方法使用递归回溯的方式来尝试从起点 `(0, 0)` 开始探索迷宫，直到找到终点或无法继续前进为止。

在每个递归步骤中，我们首先判断当前位置是否越界或为墙壁，如果是则返回 `false`。然后判断是否到达终点，如果是则返回 `true`，表示找到了一条可行路径。接下来，我们将当前位置标记为已访问，并递归尝试上、下、左、右四个方向的移动，如果其中任意方向能够找到终点，则返回 `true`。如果四个方向都无法到达终点，则将当前位置重新标记为可通行路径，返回 `false`。

在 `main` 方法中，我们调用 `solveMaze` 方法，并根据返回结果输出相应的信息。

该示例演示了如何使用递归回溯法解决迷宫问题。通过不断尝试不同的路径，并在遇到障碍或无法继续前进时回溯，最终找到一条通往终点的路径



### 八皇后问题

八皇后问题是一个经典的回溯算法问题，旨在找到一种在8x8的国际象棋棋盘上摆放八个皇后，使得每个皇后都无法互相攻击（即不在同一行、同一列或同一对角线上）。具体来说，要求找到所有不同的解法。

**解决八皇后问题的思路如下**：

1. 确定问题的规模：八皇后问题是在一个8x8的棋盘上放置8个皇后，使得每个皇后都不互相攻击。每个皇后占据一个行和列，因此可以使用一个一维数组来表示每个皇后的位置，数组的索引表示行，数组的值表示列。
2. 定义递归函数：定义一个递归函数，用于逐行放置皇后。该函数的输入参数包括当前所放置的行数和之前已经放置好的皇后位置数组。
3. 设定递归终止条件：当递归的行数等于棋盘的大小时，表示所有皇后已经放置完成，可以得到一个解决方案。在终止条件下，将解决方案添加到结果集中。
4. 在当前行放置皇后：从当前行的第一列开始遍历，尝试将皇后放置在每个列上。在放置之前，需要检查当前位置是否与之前放置的皇后位置冲突。如果冲突，则尝试下一个列；如果不冲突，则将当前位置标记为皇后的位置，并递归调用下一行。
5. 回溯操作：如果当前行的所有列都尝试完毕仍然没有找到合适的位置，或者已经找到了所有解决方案，需要进行回溯操作。回溯操作包括撤销当前行的皇后位置，返回上一行，并继续尝试下一列的位置。
6. 遍历所有解决方案：通过递归调用，不断在每一行放置皇后，直到找到所有解决方案或遍历完所有可能的位置。
7. 输出结果：将找到的解决方案进行输出，可以打印出皇后的位置或其他形式的展示。

下面是一个简单的Java代码示例，用于解决八皇后问题：

```Java
public class EightQueens {
    private static final int SIZE = 8; // 棋盘大小
    private static int[] queens = new int[SIZE]; // 皇后位置数组，该数组中的元素的索引正好对应行的索引，值对应列

    // 判断当前位置是否与之前的皇后位置冲突
    private static boolean isConflict(int row, int col) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col || queens[i] - col == i - row || queens[i] - col == row - i) {
                return true; // 冲突
            }
        }
        return false; // 不冲突
    }

    // 回溯算法解决八皇后问题
    private static void solveQueens(int row) {
        if (row == SIZE) {
            printQueens();
            return;
        }

        for (int col = 0; col < SIZE; col++) {	
            if (!isConflict(row, col)) {
                queens[row] = col; // 放置皇后
                solveQueens(row + 1); // 递归放置下一行的皇后
            }
        }
    }

    // 打印皇后位置
    private static void printQueens() {
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                //索引对应皇后的行号，索引处的值对应皇后的列号，遍历的列号与值相等时给该位置标记皇后位置。
                if (queens[i] == j) {
                    System.out.print("Q ");
                } else {
                    System.out.print("* ");
                }
            }
            System.out.println();
        }
        System.out.println();
    }

    public static void main(String[] args) {
        solveQueens(0); // 从第0行开始放置皇后
    }
}
```


## 时间空间复杂度

### 时间复杂度

时间复杂度是一种衡量算法执行时间随着输入规模增长而增长的度量。它用来估算算法的执行效率和资源消耗。

时间复杂度通常用大O符号表示，表示算法的最坏情况下执行时间与输入规模的增长关系。常见的时间复杂度包括：

1. O(1)：常数时间复杂度，表示算法的执行时间与输入规模无关，无论输入的大小如何，算法都能在相同的时间内完成。例如，访问数组中的某个元素、执行简单的数学运算等。
2. O(log n)：对数时间复杂度，表示算法的执行时间随着输入规模的增加而增加，但增长速度相对较慢，常见于二分查找等分治算法。例如，二分查找算法的时间复杂度为O(log n)。
3. O(n)：线性时间复杂度，表示算法的执行时间与输入规模成线性关系，当输入规模增加一倍时，执行时间也会增加一倍。例如，遍历数组、查找列表中的元素等。
4. O(n log n)：线性对数时间复杂度，表示算法的执行时间随着输入规模的增加而以较快的速度增加。常见于一些高效的排序算法，如快速排序和归并排序。
5. O(n^2)：平方时间复杂度，表示算法的执行时间随着输入规模的增加而呈平方关系，常见于嵌套循环等算法。例如，冒泡排序和选择排序的时间复杂度为O(n^2)。
6. O(2^n)：指数时间复杂度，表示算法的执行时间呈指数级增长。通常是因为算法中存在递归或指数级的穷举操作。指数时间复杂度的算法通常是效率最低的，尽量要避免使用。
7. O(n!)：阶乘时间复杂度，表示算法的执行时间呈阶乘级增长。通常是因为算法中存在全排列或穷举操作。阶乘时间复杂度的算法是最低效的，几乎无法应用于实际问题。

![image-20230519014121753](C:/Users/满目温柔/AppData/Roaming/Typora/typora-user-images/image-20230519014121753.png)

#### 常数时间复杂度

以下是一些常见的常数阶代码示例：

1. 赋值语句：例如 `int x = 5;`，无论变量 `x` 的值是多少，赋值操作的执行时间都是恒定的。
2. 数学运算：例如 `int result = 2 + 3;`，对于简单的数学运算，其执行时间也是固定的。
3. 条件判断：例如 `if (x > 0) { ... }`，无论条件判断的结果是真还是假，判断操作的执行时间是恒定的。
4. 访问数组元素：例如 `int value = array[0];`，无论数组的大小如何，访问数组元素的时间是固定的。

需要注意的是，虽然常数阶代码的执行时间固定，但它并不意味着常数阶代码的执行速度一定很快。在实际应用中，常数阶代码可能会被多次执行，因此它们的执行次数可能会对整体的性能产生影响。



#### 对数时间复杂度

在这个示例中，我们使用 `while` 循环来执行相同的逻辑。循环的条件是 `i` 小于 `n`，每次循环时，`count` 增加一次，并将 `i` 乘以 2。

这个循环的执行次数也是按对数方式增长的，因为 `i` 的增长速度是指数级别的。循环将继续执行直到 `i` 大于或等于 `n`。

```Java
public static int logarithmicAlgorithm(int n) {
    int count = 0;
    int i = 1;

    while (i < n) {
        count++;
        i *= 2;
    }

    return count;
}
```



#### 线性时间复杂度

在这个示例代码中，我们使用一个 `for` 循环打印从 0 到 n-1 的整数。循环的次数与输入参数 n 成正比，因此代码的执行时间与输入规模呈线性关系。

```Java
public static void linearAlgorithm(int n) {
    for (int i = 0; i < n; i++) {
        System.out.println(i);
    }
}
```



#### 线性对数时间复杂度

在这个示例代码中，我们使用插入排序算法对整数数组进行排序。插入排序的平均时间复杂度是 O(nlog n)，因此这个示例代码的时间复杂度也是 O(nlog n)。

```java
public static void nLogNAlgorithm(int[] array) {
    int n = array.length;
    
    for (int i = 1; i < n; i++) {
        int key = array[i];
        int j = i - 1;

        while (j >= 0 && array[j] > key) {
            array[j + 1] = array[j];
            j--;
        }

        array[j + 1] = key;
    }
}
```



#### 平方时间复杂度

在这个示例代码中，我们使用了嵌套的两个 `for` 循环来遍历数组中的元素。

```java 
public static void quadraticAlgorithm(int[] array) {
    
    for (int i = 0; i < array.length; i++) {
        for (int j = 0; j < array[i].length; j++) {
            System.out.println(array[i][j]);
        }
    }
}
```



#### 指数时间复杂度

在这个示例代码中，我们使用递归方式实现了一个指数级别的算法。函数 `exponentialAlgorithm` 接收一个整数参数 `n`，表示要计算的值。在函数内部，我们首先检查基本情况，如果 `n` 小于等于 0，则返回 1。这是递归的出口条件，用于结束递归的调用链。如果 `n` 大于 0，我们将递归调用 `exponentialAlgorithm` 两次，并将结果相加。这意味着每次递归调用会将问题的规模减少一半，因此总共的递归调用次数是指数级别的。

```java
public static int exponentialAlgorithm(int n) {
    if (n <= 0) {
        return 1;
    } else {
        return exponentialAlgorithm(n - 1) + exponentialAlgorithm(n - 1);
    }
}
```



#### 阶乘时间复杂度

在这个示例代码中，我们使用递归方式实现了一个计算阶乘的函数。函数 `factorial` 接收一个整数参数 `n`，表示要计算阶乘的数。

```java
public static int factorial(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
```



### 空间复杂度

数据结构的空间复杂度是指该数据结构在存储数据时所需要的额外空间，通常以大 O 表示。

以下是一些常见数据结构的空间复杂度：

1. 数组（Array）：数组的空间复杂度为 O(n)，其中 n 是数组的长度。数组需要连续的内存空间来存储元素。
2. 链表（Linked List）：单链表的空间复杂度为 O(n)，双链表的空间复杂度为 O(n)，其中 n 是链表中的节点数。链表中每个节点需要额外的指针来存储下一个节点的地址。
3. 栈（Stack）：栈的空间复杂度取决于栈中元素的数量。如果栈的最大容量是固定的，则空间复杂度为 O(1)；如果栈的容量是可变的，则空间复杂度为 O(n)，其中 n 是栈中元素的数量。
4. 队列（Queue）：队列的空间复杂度也取决于队列中元素的数量。如果队列的最大容量是固定的，则空间复杂度为 O(1)；如果队列的容量是可变的，则空间复杂度为 O(n)，其中 n 是队列中元素的数量。
5. 哈希表（Hash Table）：哈希表的空间复杂度取决于哈希表中存储的键值对数量。在理想情况下，哈希表的空间复杂度为 O(n)，其中 n 是键值对的数量。然而，由于哈希碰撞等因素，实际的空间复杂度可能会略高。
6. 二叉树（Binary Tree）：二叉树的空间复杂度取决于树中节点的数量。在最坏情况下，二叉树的空间复杂度为 O(n)，其中 n 是树中节点的数量。在平衡二叉树等特殊情况下，空间复杂度可能会降低。

需要注意的是，上述空间复杂度是指数据结构本身所需要的空间，不包括存储数据元素所占用的空间。此外，某些数据结构可能会在特定操作过程中临时占用额外的空间，例如排序算法中的临时数组等，这些额外空间也会对空间复杂度产生影响。
